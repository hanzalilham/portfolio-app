---
title: "Supabase RPC vs Firebase: what I learned shipping two Flutter apps"
description: "Two production mobile apps, two backend paradigms â€” comparing PostgreSQL RPC functions against Firebase's document model in practice."
date: "2025-01-08"
tags: ["Flutter", "Supabase", "Firebase", "BLoC", "PostgreSQL", "Stripe"]
---

I shipped two Flutter apps back to back with completely different backends. Not by plan, just by what each project needed. Coming out the other side with both in production gave me a clearer picture of when to use what than any comparison article ever did.

The first is a ride-hailing platform. I used Supabase, but not the way most people use it. The common approach is to use the Supabase client like a Firebase replacement, querying tables directly from the app. I went a different way: all data access goes through PostgreSQL RPC functions. Each function is defined with `LANGUAGE sql STABLE SECURITY DEFINER`, which means it runs with elevated privileges and access control lives entirely in the database layer rather than being scattered across the client. A service-role client handles operations that need to cross user boundaries. Driver discovery does rating-based sorting with multi-field text search across driver names, business names and vehicles, all in a single SQL function. The functions are versioned in a `SETUP_SQL.sql` file alongside the app code so the schema and queries always stay in sync.

The `SECURITY DEFINER` piece is worth being careful about. Those functions run as the database owner, so a bug in the SQL can expose data across users. They need proper test coverage. But the tradeoff is worth it for anything with complex data access patterns. You write the query once in SQL, where you have the full power of the database, and the app just calls a function. No trying to express joins and filters through a client library's query API.

The second app is doozyJo. Firebase this time. BLoC for state management throughout, Google Calendar API integration via the `googleapis` package, ships on iOS, Android and macOS from one codebase with i18n from the start. Firebase was the right call here because the data model is simpler and real-time sync out of the box saved a lot of work.

Stripe integration on doozyJo taught me something I didn't expect. The actual code for calling the Stripe API is not the hard part. The hard part is the payment flow design: getting the intent creation, client-side confirmation, webhook handling and failure recovery sequenced correctly. If you get the flow wrong you end up with payments that charge but don't fulfill, or fulfillments without payment. The code is almost secondary.
