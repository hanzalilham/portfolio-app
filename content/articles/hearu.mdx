---
title: "Implementing AWS Transcribe Streaming in Dart because there was no SDK"
description: "Building real-time audio transcription in Flutter by implementing the AWS EventStream protocol and SigV4 signing from scratch."
date: "2024-10-20"
tags: ["Flutter", "AWS Transcribe", "HTTP/2", "Spring Boot", "JWT", "PostgreSQL"]
---

Most transcription apps work the same way: you record, you upload, you wait. I wanted something different, text appearing as you speak. AWS Transcribe Streaming can do that over HTTP/2, but there is no official Dart SDK. If you want it in a Flutter app, you build the protocol yourself.

The pipeline is a chain of Dart `StreamTransformer`s. Raw PCM audio from the microphone comes in first. `AudioDataChunker` splits it into 6400-byte frames. `AudioEventEncoder` wraps each frame in the AWS event envelope format. `EventStreamEncoder` encodes the whole thing into the AWS EventStream binary format, which has its own big-endian byte ordering and CRC32 checksums in the headers. `AudioMessageSigner` signs each frame with SigV4. Then a final encoder wraps everything in HTTP/2 data frames before it goes out over the wire.

The connection itself is a TLS `SecureSocket` with ALPN `h2` negotiated to `transcribestreaming.us-east-1.amazonaws.com:443`. The Dart `http2` package handles the transport layer but the documentation is nearly nonexistent. Getting bidirectional streaming working required reading the package source code to understand how to open a stream and push data through it while simultaneously receiving transcript events back.

SigV4 signing for streaming is where most of the time went. AWS requires each frame to be signed individually, and each signature has to chain from the previous one. The first frame signs against the signature of the initial HTTP request. The second frame signs against the first frame's signature. If you get any link in that chain wrong the entire stream is rejected, and the error message tells you almost nothing useful. It took a lot of iteration to get right.

The backend is a Spring Boot 3.4 API. JWT auth using HMAC-SHA256, extracted with a custom `OncePerRequestFilter` that runs before Spring Security's default filter chain. Passwords hashed with BCrypt. JPA entities for users, notes and folders with `@ManyToOne` and `@ManyToMany` relationships. One thing that matters in production: `ddl-auto=validate` instead of `update`. Let Hibernate verify your schema matches your entities at startup, but manage the actual schema changes yourself. Letting Hibernate modify production tables automatically is asking for trouble.
